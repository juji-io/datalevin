<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Datalevin Server/Client</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Datalevin</span> <span class="project-version">0.5.31</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="dtlv.html"><div class="inner"><span>Datalevin Command Line Tool</span></div></a></li><li class="depth-1  current"><a href="server.html"><div class="inner"><span>Datalevin Server/Client</span></div></a></li><li class="depth-1 "><a href="upgrade.html"><div class="inner"><span>Datalevin Database Upgrade</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datalevin</span></div></div></li><li class="depth-2 branch"><a href="datalevin.client.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>client</span></div></a></li><li class="depth-2 branch"><a href="datalevin.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2"><a href="datalevin.interpret.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interpret</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#datalevin-server-client" name="datalevin-server-client"></a>Datalevin Server/Client</h1>
<h2><a href="#usage" name="usage"></a>Usage</h2>
<p>Using the same native command line tool, <code>dtlv serv</code> will run in the server mode and accepts network connection on port 8898 (default).</p>
<ul>
  <li>Use option <code>-p</code> to specify an alternative port number that the server listens  to. Proper firewall settings is needed to allow remote access to the port.</li>
  <li><code>-r</code> option can be used to specify a root directory path on the server, where  all data reside under. The default path is <code>/var/lib/datalevin</code> on Posix  systems, <code>C:\ProgramData\Datalevin</code> on Windows. User should  make sure read/write file permissions are set on the directory path for the  user running the server.</li>
  <li><code>-v</code> option enables verbose server debug logs. Datalevin server writes logs to  stdout.</li>
</ul>
<p>There is a default builtin user <code>datalevin</code> with a default password <code>datalevin</code>. This is a system account that can do everything on the server. It is recommended that the default password should be reset immediately after installation:</p>
<ol>
  <li>
  <p>Start the server, maybe as a sudo user, to access the default data root directory</p>
  <pre><code class="console"># dtlv serv
</code></pre></li>
  <li>
  <p>Start Datalevin REPL in another terminal</p>
  <pre><code class="console">$ dtlv
</code></pre></li>
  <li>Type the following in the REPL</li>
</ol>
<pre><code class="console">user&gt; (def client (new-client "dtlv://datalevin:datalevin@localhost"))
#'user/client
user&gt; (reset-password client "datalevin" "new-password")
nil
</code></pre>
<p>It is suggested to create different users for access to the server (see below). Leave the <code>datalevin</code> user for server administration purpose only.</p>
<p>The user is recommended to run the server process as a daemon or service using the preferred operation system tools, e.g. systemd on Linux, Launch Daemon on MacOS, or sc.exe on Windows. Packagers are welcomed to package Datalevin server on the preferred platforms.</p>
<p>For remote access, username and password is required on the connection URI. Make sure username and password are URL encoded strings on the URI.</p>
<p>When a client (for now, just the Datalevin library itself) opens a Datalevin database using a connection URI, i.e. <code>dtlv://&lt;username&gt;:&lt;password&gt;@&lt;hostname&gt;:&lt;port&gt;/&lt;db-name&gt;?store=datalog|kv</code>, instead of a local path name, a connection to the server is attempted.</p>
<p><code>db-name</code> should be unique on the server. <code>store</code> parameter is optional, default is <code>datalog</code>, the other option is <code>kv</code> for key-value store. A database will be created if it does not yet exist. <code>port</code> is optional, default is <code>8898</code>.</p>
<p>The same functions for local databases work on the remote databases, i.e. any function that takes a <code>dir</code> argument can also take a connection URI string, e.g. <code>(get-conn "dtlv://datalevin:datalevin@localhost/mydb")</code>. The remote access is transparent to the function callers.</p>
<h2><a href="#implementation" name="implementation"></a>Implementation</h2>
<p>The client/server mode is enabled with little changes to the Datalevin core library.</p>
<h3><a href="#architecture" name="architecture"></a>Architecture</h3>
<p>As mentioned, the main design criteria is to have transparent remote databases access that has the same API as local databases. This is achieved by building a remote access layer to proxy the database storage. Each local storage access function has a corresponding proxy function that performs remote storage access over the wire. That is to say, the local and remote storage present exactly the same interface to the higher level callers.</p>
<p>Compared with traditional client/server architecture, where the server performs all the actual data processing work, the architecture of Datalevin enable easier implementation of rich user convenience features. For much of the high level functionalities sit on top of storage, such as caching, transaction data preparation, query parse, change listening, and so on, they are handled on the client side, which is the same as in the local embedded mode. For example, our recent added feature of <a href="https://github.com/juji-io/datalevin#entities-with-staged-transactions-datalog-store">transactable entity</a> works the same in either embedded or server mode, without needing any code changes.</p>
<p>Compared with the peer architecture of Datomic®, where peers receive all the data, Datalevin clients requests only the needed data on demand. The amount of network traffic is reduced, clients are simpler than peers and have less work to do, so the impact on the user application performance is minimized. Because not all the data are duplicated on all the peers, the size of the database only depends on the capacity of the server, which can afford to be a beefy machine.</p>
<p>In Datalevin client/server mode, transaction and querying can happen both in client and server side, depending on the context. For example, for queries having a single remote data source, the entire query processing is done remotely to save networking traffic. For other cases, only low level data access functions are handled on the server.</p>
<p>Each client always check <code>last-modified</code> time of the remote database before data access, so when multiple clients are accessing the same database on the server, all see the same most update-to-date data, as long as the clients and the server have clock synchronization, which is a mild condition that most modern server deployment environment should meet, with ntp or chrony services being part of the standard server environment. In term of CAP theorem, Datalevin favors consistency over availability, in consistent with our goal of simplifying data access.</p>
<p>All these are transparent to the users and the same data access API works for all cases. Further optimizations can be implemented behind the scene without having to introduce new operational complexities.</p>
<h3><a href="#networking" name="networking"></a>Networking</h3>
<p>The server employs a non-blocking event driven architecture, so it can support a large number of concurrent connected clients. The server event loop runs as a single process. It accepts and segments incoming bytes from the network into messages, then dispatches them to a work stealing thread pool to handle each individual message.</p>
<p>Work stealing thread pool reduces lock contentions and maximizes the server CPU utilization. Each thread processes its message and writes its own response back to the network channel when it becomes ready, so the server message handling is asynchronous. It is the client’s responsibility to track request/response correspondence if multiple messages are on the wire.</p>
<p>For developer convenience, the current implemented client in the library makes synchronous and blocking network connections. For normal commands, it sends a request and waits for the responses from the server, so the data access API is the same for both the local databases and remote databases. In addition, the client has a built-in connection pool, to reuse pre-established connections.</p>
<p>The wire protocol between server and client is largely inspired by the wire protocol of PostgreSQL. It uses TLV message format, with 1 byte message type in front, followed by 4 bytes message length, and concludes with the message payload.</p>
<p>The payload format is extensible, indicated by the message type byte. For example, with type <code>1</code>, <a href="https://github.com/cognitect/transit-format">transit+json</a> encoded bytes will be the payload. The default payload format is type <code>2</code>, using <a href="https://github.com/ptaoussanis/nippy">nippy</a> serialization.</p>
<p>nippy format produces smaller bytes with faster speed, but it only works with Clojure code. If a client needs to be written for other languages, transit is a better choice. The server accepts either format just as well. Other format may be added in the future if necessary.</p>
<p>The command messages are EDN maps, e.g. <code>{:type :list-databases :args []}</code>. The command responses are also EDN maps. e.g. <code>{:type :command-complete :results
["mydb" "hr-db"]}</code>. For bulk data, the client/server switch to a direct copy-in/copy-out sub-protocol, where data are continuously streamed. The copy-in/copy-out data stream messages are batched data in EDN vectors instead of maps.</p>
<p>User defined functions (e.g. filtering predicates) are serialized and sent to server for execution. They are first evaluated in the sandbox using a Clojure interpreter, i.e. <a href="https://github.com/borkdude/sci">sci</a> based on a white list. Once interpreted, they become the same kind of Clojure functions as if compiled, so the performance hit is minimal. It is also more secure, as there’s less danger of malicious user code bringing down the server.</p>
<h3><a href="#security" name="security"></a>Security</h3>
<p>Datalevin server implements full-fledged role based access control (RBAC). Permissions are granted to roles, and roles are assigned to users. User access is secured by password.</p>
<p>A permission consists of three pieces of information:</p>
<ul>
  <li><code>:permission/act</code> indicates the permitted actions, and it can be one of  <code>:datalevin.server/view</code>, <code>:datalevin.server/alter</code>,  <code>:datalevin.server/create</code>, or <code>:datalevin.server/control</code>, in increasing  level of privilege, and the latter implies the former.</li>
  <li><code>:permission/obj</code> indicates the object type of the securable, and it can be  one of <code>:datalevin.server/user</code>, <code>:datalevin.server/role</code>,  <code>:datalevin.server/database</code>, or <code>:datalevin.server/server</code>, with the last one  implies all others.</li>
  <li><code>:permission/tgt</code> refers to the concrete target of the securable. It could be  a username, a role keyword, a database name or <code>nil</code>, depending on  <code>permission/obj</code>. All these target names uniquely identify securable objects.  When the target is <code>nil</code>, the permission applies to all objects of that type.</li>
</ul>
<p>Each user has a corresponding built-in unique role, with a role keyword <code>:datalevin.role/&lt;username&gt;</code>. For example, the default user <code>datalevin</code> has a built-in role <code>:datalevin.role/datalevin</code>. This role is granted the permission <code>{:permission/act :datalevin.server/control, :permission/obj
:datalevin.server/server}</code>, which permits the role to do everything on the server.</p>
<p>In the command line REPL, after connecting to a server, issue <a href="https://juji-io.github.io/datalevin/datalevin.client.html#var-create-user"><code>(create-user
...)</code></a> to create a user, <a href="https://juji-io.github.io/datalevin/datalevin.client.html#var-create-role"><code>(create-role ...)</code></a> to create a role, <a href="https://juji-io.github.io/datalevin/datalevin.client.html#var-assign-role"><code>(assign-role
...)</code></a> to assign a role to a user, <a href="https://juji-io.github.io/datalevin/datalevin.client.html#var-grant-permission"><code>(grant-permission ...)</code></a> to grant a permission to a role.</p>
<p>User password is stored as a salt and a hash. The password hashing algorithm takes the recommended more than 0.5 seconds to run on a modern server class machine, so it can defeat a brutal force cracking effort.</p></div></div></div></body></html>