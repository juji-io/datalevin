<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>datalevin.lmdb documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Datalevin</span> <span class="project-version">0.3.8</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>datalevin</span></div></div></li><li class="depth-2 branch"><a href="datalevin.bits.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>bits</span></div></a></li><li class="depth-2 branch"><a href="datalevin.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 current"><a href="datalevin.lmdb.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>lmdb</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="datalevin.lmdb.html#var-ILMDB"><div class="inner"><span>ILMDB</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-clear-dbi"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clear-dbi</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-close"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>close</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-closed.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>closed?</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-drop-dbi"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>drop-dbi</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-entries"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>entries</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-get-dbi"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-dbi</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-get-first"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-first</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-get-range"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-range</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-get-some"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-some</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-get-value"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-value</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-open-dbi"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>open-dbi</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-range-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>range-count</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-range-filter"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>range-filter</span></div></a></li><li class="depth-2 branch"><a href="datalevin.lmdb.html#var-range-filter-count"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>range-filter-count</span></div></a></li><li class="depth-2"><a href="datalevin.lmdb.html#var-transact"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transact</span></div></a></li><li class="depth-1"><a href="datalevin.lmdb.html#var-open-lmdb"><div class="inner"><span>open-lmdb</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">datalevin.lmdb</h1><div class="doc"><div class="markdown"><p>API for Key Value Store</p></div></div><div class="public anchor" id="var-ILMDB"><h3>ILMDB</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><div class="markdown"></div></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-clear-dbi"><h3>clear-dbi</h3><div class="usage"><code>(clear-dbi db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Clear data in the DBI (i.e sub-db), but leave it open</p></div></div></div><div class="public anchor" id="var-close"><h3>close</h3><div class="usage"><code>(close db)</code></div><div class="doc"><div class="markdown"><p>Close this LMDB env</p></div></div></div><div class="public anchor" id="var-closed.3F"><h3>closed?</h3><div class="usage"><code>(closed? db)</code></div><div class="doc"><div class="markdown"><p>Return true if this LMDB env is closed</p></div></div></div><div class="public anchor" id="var-drop-dbi"><h3>drop-dbi</h3><div class="usage"><code>(drop-dbi db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Clear data in the DBI (i.e. sub-db), then delete it</p></div></div></div><div class="public anchor" id="var-entries"><h3>entries</h3><div class="usage"><code>(entries db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Get the number of data entries in a DBI (i.e. sub-db)</p></div></div></div><div class="public anchor" id="var-get-dbi"><h3>get-dbi</h3><div class="usage"><code>(get-dbi db dbi-name)</code></div><div class="doc"><div class="markdown"><p>Lookup open DBI (i.e. sub-db) by name, throw if it’s not open</p></div></div></div><div class="public anchor" id="var-get-first"><h3>get-first</h3><div class="usage"><code>(get-first db dbi-name k-range)</code><code>(get-first db dbi-name k-range k-type)</code><code>(get-first db dbi-name k-range k-type v-type)</code><code>(get-first db dbi-name k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return the first kv pair in the specified key range;</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>If both key and value are ignored, return true if found an entry, otherwise  return nil.</p>
<p>Examples:</p>
<pre><code>      (get-first lmdb "c" [:all] :long :long)
      ;;==&gt; [0 1]

      ;; ignore value
      (get-first lmdb "c" [:all-back] :long :ignore)
      ;;==&gt; [999 nil]

      ;; ignore key
      (get-first lmdb "a" [:greater-than 9] :long :data true)
      ;;==&gt; {:some :data}

      ;; ignore both, this is like testing if the range is empty
      (get-first lmdb "a" [:greater-than 5] :long :ignore true)
      ;;==&gt; true
</code></pre></div></div></div><div class="public anchor" id="var-get-range"><h3>get-range</h3><div class="usage"><code>(get-range db dbi-name k-range)</code><code>(get-range db dbi-name k-range k-type)</code><code>(get-range db dbi-name k-range k-type v-type)</code><code>(get-range db dbi-name k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return a seq of kv pairs in the specified key range;</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (get-range lmdb "c" [:at-least 9] :long :long)
      ;;==&gt; [[10 11] [11 15] [13 14]]

      ;; ignore value
      (get-range lmdb "c" [:all-back] :long :ignore)
      ;;==&gt; [[999 nil] [998 nil]]

      ;; ignore keys, only return values
      (get-range lmdb "a" [:closed 9 11] :long :long true)
      ;;==&gt; [10 11 12]

      ;; out of range
      (get-range lmdb "c" [:greater-than 1500] :long :ignore)
      ;;==&gt; [] 
</code></pre></div></div></div><div class="public anchor" id="var-get-some"><h3>get-some</h3><div class="usage"><code>(get-some db dbi-name pred k-range)</code><code>(get-some db dbi-name pred k-range k-type)</code><code>(get-some db dbi-name pred k-range k-type v-type)</code><code>(get-some db dbi-name pred k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return the first kv pair that has logical true value of <code>(pred x)</code>,  where <code>pred</code> is a function, <code>x</code> is the <code>IMapEntry</code> fetched from the store,  with both key and value fields being a <code>ByteBuffer</code>.</p>
<p><code>pred</code> can use <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a> to read the content.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (require ' [datalevin.bits :as b])

      (def pred (fn [kv]
                 (let [^long k (b/read-buffer (key kv) :long)]
                  (&gt; k 15)))

      (get-some lmdb "c" pred [:less-than 20] :long :long)
      ;;==&gt; [16 2]

      ;; ignore key
      (get-some lmdb "c" pred [:greater-than 9] :long :data true)
      ;;==&gt; 16 
</code></pre></div></div></div><div class="public anchor" id="var-get-value"><h3>get-value</h3><div class="usage"><code>(get-value db dbi-name k)</code><code>(get-value db dbi-name k k-type)</code><code>(get-value db dbi-name k k-type v-type)</code><code>(get-value db dbi-name k k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Get kv pair of the specified key <code>k</code>.</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>If <code>ignore-key?</code> is true (default <code>true</code>), only return the value,  otherwise return <code>[k v]</code>, where <code>v</code> is the value</p>
<p>Examples:</p>
<pre><code>      (get-value lmdb "a" 1)
      ;;==&gt; 2

      ;; specify data types
      (get-value lmdb "a" :annunaki/enki :attr :data)
      ;;==&gt; true

      ;; return key value pair
      (get-value lmdb "a" 1 :data :data false)
      ;;==&gt; [1 2]

      ;; key doesn't exist
      (get-value lmdb "a" 2)
      ;;==&gt; nil 
</code></pre></div></div></div><div class="public anchor" id="var-open-dbi"><h3>open-dbi</h3><div class="usage"><code>(open-dbi db dbi-name)</code><code>(open-dbi db dbi-name key-size)</code><code>(open-dbi db dbi-name key-size val-size)</code><code>(open-dbi db dbi-name key-size val-size flags)</code></div><div class="doc"><div class="markdown"><p>Open a named DBI (i.e. sub-db) in the LMDB env</p></div></div></div><div class="public anchor" id="var-range-count"><h3>range-count</h3><div class="usage"><code>(range-count db dbi-name k-range)</code><code>(range-count db dbi-name k-range k-type)</code></div><div class="doc"><div class="markdown"><p>Return the number of kv pairs in the specified key range, does not process  the kv pairs.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>Examples:</p>
<pre><code>      (range-count lmdb "c" [:at-least 9] :long)
      ;;==&gt; 10 
</code></pre></div></div></div><div class="public anchor" id="var-range-filter"><h3>range-filter</h3><div class="usage"><code>(range-filter db dbi-name pred k-range)</code><code>(range-filter db dbi-name pred k-range k-type)</code><code>(range-filter db dbi-name pred k-range k-type v-type)</code><code>(range-filter db dbi-name pred k-range k-type v-type ignore-key?)</code></div><div class="doc"><div class="markdown"><p>Return a seq of kv pair in the specified key range, for only those  return true value for <code>(pred x)</code>, where <code>pred</code> is a function, and <code>x</code>  is an <code>IMapEntry</code>, with both key and value fields being a <code>ByteBuffer</code>.</p>
<p><code>pred</code> can use <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a> to read the buffer content.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p><code>k-type</code> and <code>v-type</code> are data types of <code>k</code> and <code>v</code>, respectively.  The allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p>Only the value will be returned if <code>ignore-key?</code> is <code>true</code>;  If value is to be ignored, put <code>:ignore</code> as <code>v-type</code></p>
<p>Examples:</p>
<pre><code>      (require ' [datalevin.bits :as b])

      (def pred (fn [kv]
                 (let [^long k (b/read-buffer (key kv) :long)]
                  (&gt; k 15)))

      (range-filter lmdb "a" pred [:less-than 20] :long :long)
      ;;==&gt; [[16 2] [17 3]]

      ;; ignore key
      (range-filter lmdb "a" pred [:greater-than 9] :long :data true)
      ;;==&gt; [16 17] 
</code></pre></div></div></div><div class="public anchor" id="var-range-filter-count"><h3>range-filter-count</h3><div class="usage"><code>(range-filter-count db dbi-name pred k-range)</code><code>(range-filter-count db dbi-name pred k-range k-type)</code></div><div class="doc"><div class="markdown"><p>Return the number of kv pairs in the specified key range, for only those  return true value for <code>(pred x)</code>, where <code>pred</code> is a function, and <code>x</code>  is an <code>IMapEntry</code>, with both key and value fields being a <code>ByteBuffer</code>.  Does not process the kv pairs.</p>
<p><code>pred</code> can use <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a> to read the buffer content.</p>
<p><code>k-type</code> indicates data type of <code>k</code> and the allowed data types are described in <a href="datalevin.bits.html#var-read-buffer">datalevin.bits/read-buffer</a>.</p>
<p><code>k-range</code> is a vector <code>[range-type k1 k2]</code>, <code>range-type</code> can be one of  <code>:all</code>, <code>:at-least</code>, <code>:at-most</code>, <code>:closed</code>, <code>:closed-open</code>, <code>:greater-than</code>,  <code>:less-than</code>, <code>:open</code>, <code>:open-closed</code>, plus backward variants that put a  <code>-back</code> suffix to each of the above, e.g. <code>:all-back</code>;</p>
<p>Examples:</p>
<pre><code>      (require ' [datalevin.bits :as b])

      (def pred (fn [kv]
                 (let [^long k (b/read-buffer (key kv) :long)]
                  (&gt; k 15)))

      (range-filter-count lmdb "a" pred [:less-than 20] :long)
      ;;==&gt; 3
</code></pre></div></div></div><div class="public anchor" id="var-transact"><h3>transact</h3><div class="usage"><code>(transact db txs)</code></div><div class="doc"><div class="markdown"><p>Update DB, insert or delete key value pairs.</p>
<p><code>txs</code> is a seq of <code>[op dbi-name k v k-type v-type put-flags]</code>  when <code>op</code> is <code>:put</code>, for insertion of a key value pair <code>k</code> and <code>v</code>;  or <code>[op dbi-name k k-type]</code> when <code>op</code> is <code>:del</code>, for deletion of key <code>k</code>;</p>
<p><code>dbi-name</code> is the name of the DBI (i.e sub-db) to be transacted, a string.</p>
<p><code>k-type</code>, <code>v-type</code> and <code>put-flags</code> are optional.</p>
<p><code>k-type</code> indicates the data type of <code>k</code>, and <code>v-type</code> indicates the data type of <code>v</code>. The allowed data types are described in <a href="datalevin.bits.html#var-put-buffer">datalevin.bits/put-buffer</a></p>
<p><code>put-flags</code> is a vector of <a href="https://www.javadoc.io/doc/org.lmdbjava/lmdbjava/latest/org/lmdbjava/PutFlags.html">LMDB put flags</a>.</p>
<p>Example:</p>
<pre><code>    (transact lmdb
              [ [:put "a" 1 2]
                [:put "a" 'a 1]
                [:put "a" 5 {}]
                [:put "a" :annunaki/enki true :attr :data]
                [:put "a" :datalevin ["hello" "world"]]
                [:put "a" 42 (d/datom 1 :a/b {:id 4}) :long :datom]
                [:put "a" (byte 0x01) #{1 2} :byte :data]
                [:put "a" (byte-array [0x41 0x42]) :bk :bytes :data]
                [:put "a" [-1 -235254457N] 5]
                [:put "a" :a 4]
                [:put "a" :bv (byte-array [0x41 0x42 0x43]) :data :bytes]
                [:put "a" :long 1 :data :long]
                [:put "a" 2 3 :long :long]
                [:del "a" 1]
                [:del "a" :non-exist] ])
</code></pre></div></div></div></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/lmdb.clj#L211">view source</a></div></div><div class="public anchor" id="var-open-lmdb"><h3>open-lmdb</h3><div class="usage"><code>(open-lmdb dir)</code><code>(open-lmdb dir size)</code><code>(open-lmdb dir size flags)</code></div><div class="doc"><div class="markdown"><p>Open an LMDB database. <code>dir</code> is a string path where the data are to be stored; <code>size</code> is the initial DB size in MB; <code>flags</code> are <a href="https://www.javadoc.io/doc/org.lmdbjava/lmdbjava/latest/index.html">LMDB EnvFlags</a>;</p>
<blockquote>
  <p>LMDB uses POSIX locks on files, and these locks have issues if one process opens a file multiple times. Because of this, do not mdb_env_open() a file multiple times from a single process. Instead, share the LMDB environment that has opened the file across all threads. Otherwise, if a single process opens the same environment multiple times, closing it once will remove all the locks held on it, and the other instances will be vulnerable to corruption from other processes.’</p>
</blockquote>
<p>A LMDB connection is stateful and should be managed as such. Multiple connections to the same DB in the same process is not recommended. The recommendation is to use one of the Clojure state management libraries such as component, mount, integrant, or whatever to hold on to and manage the stateful connection.</p></div></div><div class="src-link"><a href="https://github.com/juji-io/datalevin/blob/master/src/datalevin/lmdb.clj#L807">view source</a></div></div></div></body></html>